
'use strict';

const assert = require('assert');

const protocols = require('js-protocols');

const symbols = new protocols.util.Protocol();
symbols.getPrototypeOf = protocols.core.getPrototypeOf;

const {set, defineAndAssign} = protocols.util.symbols;

function identity( x ) { return x; }
function negate( fn ) { return function(){ return ! fn.apply(this, arguments) }; }

// setting some basic useful functions for types
{
	use protocols from symbols;

	symbols[defineAndAssign]( Object.prototype, {
		create( propertiesObject ) {
			return Object.create(this, propertiesObject);
		},
		clone() {
			return this.*collect();
		}
	});

	// redefining `create` for Exotic Objects
	[
		//Function	// no point
		Array,
		//String,	// no point
		// Proxy,

		// Generator,
		//Boolean,	// no point
		Error,
		//Number,	// no point
		Date,
		RegExp,
		Map,
		Set,
		WeakMap,
		// WeaskSet,
		ArrayBuffer,
		DataView,
		Promise,
		// ObjectCreate,
		// ListIterator,
		// Arguments,
		Int32Array.prototype.*getPrototypeOf().constructor,
		// StringIterator,
		// ArrayIterator,
		// MapIterator,
		// SetIterator,
	].forEach( (exoticType, i)=>{
		assert( !! exoticType, `exoticType[${i}] is undefined` );
		assert( !! exoticType.prototype, `exoticType[${i}] has no prototype` );
		symbols.create[set]( exoticType.prototype, function(propertiesObject){
			return new exoticType();
		});
	});
}

// setting some basic building blocks for collections used by the other algorithms
{
	use protocols from protocols.util.symbols;
	use protocols from protocols.core;

	symbols[defineAndAssign]( Object.prototype, {
		has( key ) {
			return this.*get( key ) !== undefined;
		},
		get( key ) {
			return this[key];
		},
		set( key, value ) {
			this[key] = value;
		},
		addValue( value, key ) {
			this[key] = value;
		},
		forEach( fn ) {
			for( let prop in this ) {
				fn( this[prop], prop, this );
			}
		},
		whileEach( fn ) {
			for( let prop in this ) {
			 	if( ! fn(this[prop], prop, this) ) {
					return [prop, this[prop]];
				}
			}
		},
		first( ) {
			const [, first] = whileEach( ()=>false );
			return first;
		},
		nth( n ) {
			let count = 0;

			const [, nth] = whileEach( (v)=>{
				if( count <  n ) {
					++ count;
					return true;
				}
				else {
					return false;
				}
			});
			return nth;
		},
		last( ) {
			let value;
			forEach( (v)=>{ value = v; } );
			return value;
		},
		one( ) {
			const [, first] = whileEach( ()=>false );
			return first;
		},
		only( ) {
			let iterated = false;
			let first;

			const r = whileEach( (v)=>{
				if( iterated ) {
					return false;
				}

				first = v;
				iterated = true;
			});
			assert( ! r, `.*only() found more than one item` );

			return first;
		},
		len( ) {
			return this.*reduce( (count)=>count+1, 0 );
		},
		isEmpty( ) {
			return ! this.*whileEach( ()=>false );
		}
	});

	symbols.get
		.*set( Array.prototype, function(key){ assert( key.*isNumber(), `Trying to access an Array using \`${key}\` as a key` ); return this[key]; } )
		.*set( Map.prototype, function(key){ return this.get(key); } )
		.*set( Set.prototype, function(key){ if( this.has(key) ) { return key; }; } );

	symbols.set
		.*set( Array.prototype, function(key, value){ assert(key.*isNumber(), `Trying to access an Array using \`${key}\` as a key`); this[key] = value; } )
		.*set( Map.prototype, function(key, value){ this.set(key, value); } )
		.*set( Set.prototype, function(key, value){ assert(key === value, `Trying to add a key \`${key}\` and a different value \`${value}\` to a set`); this.add(value); } );

	symbols.addValue
		.*set( Array.prototype, function(value, key){ this.push(value); } )
		.*set( Map.prototype, function(value, key){ this.set(key, value); } )
		.*set( Set.prototype, function(value, key){ this.add(value); } );

	symbols.forEach
		.*set( Array.prototype, function(fn){ this.forEach(fn); } )
		.*set( Map.prototype, function(fn){ this.forEach(fn); } )
		.*set( Set.prototype, function(fn){ this.forEach(fn); } );

	symbols.whileEach
		.*set( Array.prototype, function(fn){
			for( let i = 0; i < this.length; ++i ) {
			 	if( ! fn(this[i], i, this) ) {
					return;
				}
			}
		})
		.*set( Map.prototype, function(fn){
			for( let [key, value] of this ) {
			 	if( ! fn(value, key, this) ) {
					return;
				}
			}
		})
		.*set( Set.prototype, function(fn){
			for( let value of this ) {
			 	if( ! fn(value, value, this) ) {
					return;
				}
			}
		});

	symbols.first
		.*set( Array.prototype, function(){ return this[0]; } );

	symbols.nth
		.*set( Array.prototype, function(n){ return this[ n ]; } );

	symbols.last
		.*set( Array.prototype, function(){ return this[ this.length-1 ]; } );

	symbols.len
		.*set( Array.prototype, function(){ return this.length; } )
		.*set( Map.prototype, function(){ return this.size; } )
		.*set( Set.prototype, function(){ return this.size; } );

	symbols.isEmpty
		.*set( Array.prototype, function(){ return ! this.length; } )
		.*set( Map.prototype, function(){ return ! this.size; } )
		.*set( Set.prototype, function(){ return ! this.size; } );
}

{
	use protocols from symbols;

	symbols[defineAndAssign]( Object.prototype, {
		map( fn ) {
			const out = this.*getPrototypeOf().*create();
			this.*forEach( (value, key)=>{
				out.*addValue( fn(value, key, this), key );
			});
			return out;
		},
		filter( fn ) {
			const out = this.*getPrototypeOf().*create();
			this.*forEach( (value, key)=>{
				if( fn(value, key, this) ) {
					out.*addValue( value, key );
				}
			});
			return out;
		},
		reduce( fn, initialValue ) {
			let v = initialValue;
			this.*forEach( (value, key)=>{
				v = fn( v, value, key, this );
			});
			return v;
		},
		reduce0( fn ) {
			return this.*drop(1).reduce( fn, this.*first() );
		},

		some( fn ) {
			return !! this.*whileEach( negate(fn) );
		},
		every( fn ) {
			return ! this.*whileEach( fn );
		},

		zip( ...collections ) {
			const out = this.*getPrototypeOf().*create();
			this.*forEach( (value, key)=>{
				const values = collections.*map( (collection)=>collection.*get(key) );
				out.*set( key, values );
			});
			return out;
		},
		chunk( n ) {
			assert( n >= 1, `.*chunk(n): n must be >=1, while it's \`${n}\`` );
			const out = [];

			let collection = this.*getPrototypeOf().*create();
			out.push( collection );

			let count = 0;

			this.*forEach( (value, key)=>{
				collection.*addValue( value, key );

				++ count;
				if( count >= n ) {
					collection = this.*getPrototypeOf().*create();
					out.push( collection );
					count = 0;
				}
			});

			return out;
		},

		drop( n=1 ) {
			assert( n >= 0, `.*chunk(n): n must be >=0, while it's \`${n}\`` );
			const out = this.*getPrototypeOf().*create();
			let count = 0;
			this.*forEach( (value, key)=>{
				if( count < n ) {
					++ count;
				}
				else {
					out.*addValue( value, key );
				}
			});
			return out;
		},
		dropWhile( test ) {
			const out = this.*getPrototypeOf().*create();
			let dropping = true;
			this.*forEach( (value, key)=>{
				if( dropping ) {
					dropping = test(value, key, this);
					if( dropping ) {
						return;
					}
				}
				else {
					out.*addValue( value, key );
				}
			});
			return out;
		},

		defaults( ...sources ) {
			sources.forEach( (source)=>{
				source.*forEach( (value, key)=>{
					if( ! this.*has(key) ) {
						this.*set( key, value );
					}
				});
			});
			return this;
		},
		assign( ...sources ) {
			sources.forEach( (source)=>{
				source.*forEach( (value, key)=>{
					this.*set( key, value );
				});
			});
			return this;
		},

		fromPairs( targetType=Object ) {
			const out = targetType.prototype.*create();
			this.*forEach( ([value, key])=>{
				out.*set( key, value );
			});
			return out;
		},

		keys( ) {
			const out = [];
			this.*forEach( (value, key)=>{ out.*addValue(key); } );
			return out;
		},
		values( ) {
			const out = [];
			this.*forEach( (value, key)=>{ out.*addValue(value); } );
			return out;
		},
		entries( ) {
			const out = [];
			this.*forEach( (value, key)=>{ out.*addValue([key, value]); } );
			return out;
		},

		collect( targetType ) {
			const targetProto = targetType === undefined ?
				this.*getPrototypeOf() :
				targetType.prototype;

			const out = targetProto.*create();
			this.*forEach( (value, key)=>{
				out.*addValue( value, key );
			});
			return out;
		},
	});
}

module.exports = symbols;

if( require.main === module ) {
	use protocols from symbols;

	console.log( [1,5,7].*clone() );
	console.log( {a:7, b:5, c:1}.*clone() );
	console.log( new Map([[1,'a'], ['b',2]]).*clone() );
	console.log( {a:7, b:5, c:1}.*collect( Map ).*clone().*chunk(2) );
	console.log( [['a',7], ['b',5], ['c',1]].*fromPairs( Map ).*clone() );
	console.log( [7, 'bao', {x:0}].*collect(Set).*clone() );
}
