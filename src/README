
New idea

Each collection should define its own core methods with very specific semantics:
 - get(key) returns `value` for key - only Map, Array, Range, slice have it
 - has(key) returns true or false whether `key` is in the collection
 - add(value) pushes a value in, Array and Set have it
 - len() returns the collection size in O(1)
 - count() as above, but in up to O(n)
 - nth(n) like get(), but with n natural from 0 to len()

Then, Collection.impl(Type) tries to implement stuff compatibly with what's there...
For instance it implements `chunk` by calling ChunkFactory(Type)
The Factory creates a new Chunk object based on the methods available for Type (caching already created Chunk objects) and return it...

function ChunkFactory( Type ) {
	return implForMethods( Chunker, [Type.*len, Type.*nth, Type.*get], (len, nth, get)=>{
		if( ! get ) {
			return;
		}

		const methods = {
			...
			len: len && function() {
				return Math.trunc( ... this.wrapped ... ) ...
			};
		};

		return methods;
	});
}

`implForMethods` caches Chunker for the specified methods, calls `Collection.impl()` on Chunker and returns it

this way methods will only be available on compatible collections (and collection wrappers obv) and everything will be optimized

...how do we deal with stuff like sort() now?
should it operate in place or not??
