
# TODOs, ideas

A `collection` passes the `compiler configuration` to the compiler processor.
The `compiler configuration` is used to build the `core protocol generators` for the `collection`. It should include some `core protocol generators` or functions to generate them (e.g. `nStage`, `stage`).

Both `core protocols` and `derived protocols` can be implemented using the `core protocol generators`.


Note that some functions in the `compiler configuration` are used to generate `core protocol generators` (e.g. `nStage`=>(`nth`,`stage`); `stage`=>`get`; `nth`=>`set` etc), while others are directly used and never overridden (e.g. `len`, `nth`).
`Decorators` can use `stage` and `nStage` to easily define most `core generators`. They should work (in different ways of course) both when the inner collection has the needed `core protocol generators` and when it doesn't but has `core protocols` instead.

## Current status
Currently we have something similar to `compilable collection`: what's returned by `CompilerDefinition.prototype.instantiate`.
`CompilerDefinition` isn't really needed and it should be dropped.

## Definitions
 - `(collection) core protocols`: the core protocols to manipulate a collection. For instance `nth`, `get`, `len` etc.
 - `(collection) derived protocols`: higher level protocols that are generated from `core protocols`. For instance `forEach`, `reduce`, `count`.
 - `collection`: an object that implements all the applicable `core protocols`.
 - `root collection`: a collection generating data out of stuff which is not a collection. It includes `Array`, `Map`, `Range`, `Fibonacci` etc.
 - `decorator`: a collection that is build on top of another. The data it contains is derived from the data of the inner collection.
 - `compiler`: the component that stores the AST we're generating and offers functions to manipulate it and turn into actual code.
 - `collection compiler`: a `compiler` specific for compiling collections. It keeps track of stuff like `value`, `key`, loop's `body` etc.
 - `code generator`: a function that modifies the AST of a compiler to implement some semantics.
 - `compilable collection`: an object that implement `code generators` for all the applicable collection core protocols.
 - `core protocol generators`: the necessary information to generate a `compilable collection`. These generators are semantically different from `core protocols` and a few extra ones are supported/required, and are used to compile them. For instance `nStage`, `stage`, `nth`, `len`, `args`, `parentCollection`.
 - `compiler configuration`: stuff passed to the compiler processor that will be used to derive `core protocol generators`.

## Core protocol derivability
`nStage` => `nth`
`nStage` + `keyToN` => `stage`
`stage` => `get`, `hasKey`

## More TODOs
 - `Collection` or `Container`?
 - I should get rid of `Propagator`, but rather do something similar to `core generators`: the object passed to the impl processor should be allowed to contain stuff which is not a core protocol (e.g. `nToParentN`, `parentCollection`, `stage`, `nStage`), and this should be used to generate `core protocols` when necessary.
 - both the compiler and the impl (which includes propagator) processor, should use the same collection properties. These should also include stuff like writable.
 - `core protocols` should include a function to access the parent collection (for decorators) and the root one... Or not?

 - `core protocol generators` (or maybe just the `compiler configuration`?) should include a `localKeyToN` and `localNToKey` that can be used to generate `keyToN` and `nToKey` and doesn't decrease performance in the code generated by the version og `stage` derived by `nStage`...



# Processors

The modules in this directory offer "processors": functions that implement protocols for our collections.

When defining a new collection only a few core protocols need to specified. Using them, the processors can generate the remaining core protocols and the derived ones.

 - impl processes protocols in a straightforward way, implementing them using the supplied ones directly.
 - propagator uses the "propagator" approach: an object that defines a bunch of properties for the Collection, simplifying the definition of some protocols.
 - compiler uses the "compiler" approach: generating code for `new Function`.
 - properties should be used to define some static properties of the collection, useful to compiler and propagator

## Propagator

## Compiler

A Collection that wishes to use the compiler module should use a "Compiler Definition", an object providing everything necessary for the compilation.

Decorators's Properties need to have:
 - `parentType()`

 And their Compiler Definition needs to have:
 - `parentCollection()`: a function that returns the parent collection `this` is transforming


Every compilable collection's Properties needs to include:
 - `args`: an object with the argument of the collection. The keys are the names of the arguments and their value is a function returning the argument for the collection instance `this`.

Besides `args`, a Compiler Definition should provide compilers for the functions it wishes to use for compilation:
 - `len()`, returning an Expression with the length of the collection
 - `next( compiler )`, generating the code to do the equivalent of Propagator's `next`. It finds `code`, `key`, `value`, `loop` and `body` in `compiler`, and can use and modify these values freely.
 - `get( compiler, value, key )`
 - `stage( compiler, parentStage )`, `nStage( compiler, parentStage )`, only for derived compilers

 Note that these functions have a slightly different semantics from the core protocols. These functions should will be called with a `this` object with the following properties:
  - `this.parent`, to be used to call parent's compiler functions
  - `this.args`: an objects matching `Properties.args` whose values are Expressions nodes carrying the value of the arg.
  - the available methods (e.g. `len` etc)

The processor will create an object with functions meant to compile code for the core prototypes, set it as the [compilerSymbol] property of the collection.

### Implementation NOTEs

The Compiler Definition functions are very simple.
The ones for decorators receive an extra parameter compared to the root type ones: the result computed by the lower level.
The Compiler processor uses these definitions to generate the actual protocols. While the thing is straightforward for root types, it's slightly more complicated for decorators.
For decorators, Compiler recurses through the parents. If one ancestor lacks a core function we need, we give up and generate no function. We can end the recursion in two other cases: reaching the root type, or reaching a type with no Compiler Definition. In either case we get their value, and start bubbling up, effectively `reduce`ing the computed value.

# To think about

The following stuff can be automatically generated in a number of ways...

## For Decorators

 - `kvIterator` <- `next`+`parent.kvIterator`
 - `kvReorderedIterator` <- `next`+`parent.kvReorderedIterator`
 - `get` <- `next`+`parent.get`+`keyToParentKey` // same for `nth`

## For everything

 - `kvReorderedIterator` <- `kvIterator`

Enumerable stuff should provide `nToKey` and `keyToN`. Using this the following pairs can be derived from each other:

 - `get` - `nth`
 - `hasKey`
 - `setNth` - `set`
 - `keyToParentKey` - `nToParentN`

The following options can automate the implementation of some protocols:

 - `isInfinite:true` -> no `reverse`
 - `alwaysPropagate:true`+`propagateMulti:false` -> `hasKey`, `len`

## Last minute ideas:

`map`, `entries`, `values`, `keys`, `map_key`, `cache`, `cow`, `iter`, `reordered` should all specialize the same base class

Stuff like Cache and Cow should return a memoized specialized function dynamically, rather than statically.

It should be possible to compile a super efficient function call...
```
p = placeholder
new Range( 10, p(0) )::map( squareFn )::filter( p(1) )::reduce::compile( sumFn )
```

When compiling, If we detect that the same non-Literal-nor-Identifier expression is used in multiple places,
we should store that in a variable.

Stuff like `sorted` should have `len`, `get`, maybe(?) `nth` (it's log n, hmmm, maybe another name? logNth? lol), but no iteration etc.

### Properties:

 - `args`
 - `isInfinite`

Decorators:
 - `parentCollection`
 - `ParentType`
 - `alwaysPropagate`
 - `propagateMulti`
 - `needState`
 - `reorder`
 - `changeKey`
 - `changeValue`

## TODOs

 - get rid of `forAny` and the others: `forEach` should do it -- TODO: should we??

## NOTEs

### Chunk
Compiling into a loop within a loop.
If the parent iterator can be duplicated, it should return an iterator of iterators, otherwise reordered iterators.
### Filter
### Flatten
### GroupBy
Compiling into a loop within a loop.
### SkipWhile
Iterable only.
Should generate a pre-loop where it keeps skipping, and then a good one.
### TakeWhile
Iterable only.
### Slice
It's like skip+take+mapKey
